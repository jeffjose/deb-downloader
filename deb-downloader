#!/usr/bin/env -S uv run --script
# /// script
# dependencies = [
#   "questionary",
#   "requests",
# ]
# ///

import argparse
import re
import subprocess
import sys
import tomllib
from pathlib import Path

import questionary
import requests

# ANSI color codes
class Colors:
    GREEN = '\033[32m'
    YELLOW = '\033[33m'
    RED = '\033[31m'
    BLUE = '\033[34m'
    BOLD = '\033[1m'
    RESET = '\033[0m'


def clean_repo_line(line: str) -> str:
    """Clean up various formats of APT repository lines."""
    # Remove leading/trailing whitespace
    line = line.strip()

    # Remove 'echo' command
    line = re.sub(r'^echo\s+', '', line)

    # Remove 'sudo tee' or similar commands
    line = re.sub(r'\|\s*sudo\s+tee.*$', '', line)

    # Remove trailing pipes and backslashes (with any whitespace between/around them)
    # Keep removing until no more trailing pipes/backslashes/whitespace
    while True:
        old_line = line
        line = re.sub(r'[\s|\\]+$', '', line)
        if line == old_line:
            break

    # Trim again
    line = line.strip()

    # Remove surrounding quotes AFTER cleaning trailing stuff
    line = re.sub(r'^"(.*)"$', r'\1', line)
    line = re.sub(r"^'(.*)'$", r'\1', line)

    return line.strip()


def parse_repo_line(line: str) -> tuple[str, str, str]:
    """Parse APT repository line into URL, distribution, and component."""
    cleaned = clean_repo_line(line)

    # Check if it starts with deb or deb-src
    if not cleaned.startswith(('deb ', 'deb-src ')):
        raise ValueError(f"Invalid repository line: {cleaned}")

    # Remove 'deb' or 'deb-src'
    cleaned = re.sub(r'^(deb|deb-src)\s+', '', cleaned)

    # Remove options in brackets [...]
    cleaned = re.sub(r'\[[^\]]*\]\s*', '', cleaned)

    # Split into parts
    parts = cleaned.split()
    if len(parts) < 2:
        raise ValueError(f"Invalid repository format: {cleaned}")

    url = parts[0].rstrip('/')
    distribution = parts[1]
    component = parts[2] if len(parts) > 2 else 'main'

    return url, distribution, component


def get_architecture() -> str:
    """Get system architecture."""
    result = subprocess.run(['dpkg', '--print-architecture'],
                          capture_output=True, text=True, check=True)
    return result.stdout.strip()


def get_installed_version(package_name: str) -> str | None:
    """Get the installed version of a package, or None if not installed."""
    try:
        result = subprocess.run(
            ['dpkg', '-s', package_name],
            capture_output=True,
            text=True,
            check=False
        )
        if result.returncode == 0:
            for line in result.stdout.split('\n'):
                if line.startswith('Version: '):
                    return line.split('Version: ', 1)[1].strip()
        return None
    except:
        return None


def discover_distributions(url: str) -> list[str]:
    """Try to discover available distributions from the repository."""
    import re

    dists_url = f"{url}/dists/"

    try:
        response = requests.get(dists_url, timeout=10)
        response.raise_for_status()

        # Parse HTML directory listing for distribution names
        # Look for links that are directories (end with /)
        content = response.text

        # Match patterns like <a href="stable/">stable/</a> or similar
        pattern = r'<a[^>]*href=["\']([^"\']+)/["\'][^>]*>([^<]+)/?</a>'
        matches = re.findall(pattern, content)

        distributions = []
        for href, text in matches:
            # Clean up the distribution name
            dist = href.strip('/').split('/')[-1]
            # Skip common non-distribution directories
            if dist and dist not in ['.', '..', 'by-hash']:
                distributions.append(dist)

        return distributions
    except:
        return []


def fetch_packages_list(url: str, distribution: str, component: str, arch: str) -> list[dict]:
    """Fetch and parse the Packages file from the repository."""
    packages_url = f"{url}/dists/{distribution}/{component}/binary-{arch}/Packages"

    # Try compressed first, then uncompressed
    try:
        response = requests.get(f"{packages_url}.gz", timeout=30)
        response.raise_for_status()
        import gzip
        content = gzip.decompress(response.content).decode('utf-8')
    except:
        response = requests.get(packages_url, timeout=30)
        response.raise_for_status()
        content = response.text

    # Parse packages
    packages = []
    current_package = {}

    for line in content.split('\n'):
        if line.startswith('Package: '):
            if current_package:
                packages.append(current_package)
            current_package = {'name': line.split('Package: ', 1)[1].strip()}
        elif line.startswith('Version: '):
            current_package['version'] = line.split('Version: ', 1)[1].strip()
        elif line.startswith('Filename: '):
            current_package['filename'] = line.split('Filename: ', 1)[1].strip()
        elif line.startswith('Size: '):
            current_package['size'] = int(line.split('Size: ', 1)[1].strip())
        elif line.startswith('Description: '):
            current_package['description'] = line.split('Description: ', 1)[1].strip()

    if current_package:
        packages.append(current_package)

    return packages


def format_size(size: int) -> str:
    """Format size in bytes to human-readable format."""
    for unit in ['B', 'KB', 'MB', 'GB']:
        if size < 1024.0:
            return f"{size:.1f} {unit}"
        size /= 1024.0
    return f"{size:.1f} TB"


def compare_versions(v1: str, v2: str) -> int:
    """Compare two Debian versions. Returns 1 if v1 > v2, -1 if v1 < v2, 0 if equal."""
    try:
        result = subprocess.run(
            ['dpkg', '--compare-versions', v1, 'gt', v2],
            capture_output=True,
            check=False
        )
        return 1 if result.returncode == 0 else -1
    except:
        # Fallback to string comparison
        return 1 if v1 > v2 else -1 if v1 < v2 else 0


def process_package_config(pkg_config: dict, arch: str, output_dir: Path, install: bool, force: bool, overwrite: bool) -> bool:
    """Process a single package from config. Returns True on success."""
    name = pkg_config.get('name')
    url = pkg_config.get('url', '').rstrip('/')
    distribution = pkg_config.get('distribution')
    component = pkg_config.get('component', 'main')
    version = pkg_config.get('version')

    if not name or not url:
        print(f"{Colors.RED}✗{Colors.RESET} Missing name or url in config")
        return False

    # Auto-discover distribution if not specified
    if not distribution:
        distributions = discover_distributions(url)
        if len(distributions) == 1:
            distribution = distributions[0]
        else:
            print(f"{Colors.RED}✗{Colors.RESET} {name}: Could not determine distribution")
            return False

    print(f"{Colors.BLUE}{url}/{distribution}/{component}/{arch}{Colors.RESET}")

    # Fetch packages
    try:
        packages = fetch_packages_list(url, distribution, component, arch)
    except Exception as e:
        print(f"{Colors.RED}✗{Colors.RESET} {name}: Error fetching packages: {e}")
        return False

    if not packages:
        print(f"{Colors.RED}✗{Colors.RESET} {name}: No packages found")
        return False

    # Find the specified package
    matching_packages = [pkg for pkg in packages if pkg.get('name') == name]

    if not matching_packages:
        print(f"{Colors.RED}✗{Colors.RESET} {name}: Package not found in repository")
        return False

    # Select version
    if version and version != 'latest':
        selected = None
        for pkg in matching_packages:
            if pkg.get('version') == version:
                selected = pkg
                break
        if not selected:
            print(f"{Colors.RED}✗{Colors.RESET} {name}: Version '{version}' not found")
            return False
    else:
        # Find latest version
        selected = matching_packages[0]
        for pkg in matching_packages[1:]:
            if compare_versions(pkg.get('version', '0'), selected.get('version', '0')) > 0:
                selected = pkg

    print(f"{Colors.GREEN}→{Colors.RESET} {selected.get('name')} {Colors.BOLD}{selected.get('version')}{Colors.RESET}")

    # Download
    filename = selected.get('filename')
    if not filename:
        print(f"{Colors.RED}✗{Colors.RESET} {name}: No filename found")
        return False

    output_path = output_dir / Path(filename).name

    try:
        if output_path.exists() and not overwrite:
            print(f"{Colors.YELLOW}✓{Colors.RESET} Cached: {output_path.name}")
        else:
            download_package(url, filename, str(output_path))
            print(f"{Colors.GREEN}✓{Colors.RESET} Downloaded: {output_path.name}")

        if install:
            installed_version = get_installed_version(selected.get('name'))
            target_version = selected.get('version')

            if installed_version == target_version and not force:
                print(f"{Colors.GREEN}✓{Colors.RESET} Already installed")
            else:
                if installed_version:
                    print(f"{Colors.YELLOW}↑{Colors.RESET} Upgrading from {installed_version}")
                try:
                    subprocess.run(['sudo', 'dpkg', '-i', str(output_path)], check=True, capture_output=True)
                    print(f"{Colors.GREEN}✓{Colors.RESET} Installed")
                except subprocess.CalledProcessError:
                    try:
                        subprocess.run(['sudo', 'apt-get', 'install', '-f', '-y'], check=True, capture_output=True)
                        print(f"{Colors.GREEN}✓{Colors.RESET} Installed (dependencies fixed)")
                    except subprocess.CalledProcessError:
                        print(f"{Colors.RED}✗{Colors.RESET} Installation failed")
                        return False

        return True

    except Exception as e:
        print(f"{Colors.RED}✗{Colors.RESET} {name}: Error: {e}")
        return False


def download_package(url: str, filename: str, output_path: str):
    """Download package with progress bar."""
    download_url = f"{url}/{filename}"
    temp_path = f"{output_path}.part"

    try:
        response = requests.get(download_url, stream=True, timeout=30)
        response.raise_for_status()

        total_size = int(response.headers.get('content-length', 0))

        with open(temp_path, 'wb') as f:
            if total_size == 0:
                f.write(response.content)
            else:
                downloaded = 0
                for chunk in response.iter_content(chunk_size=8192):
                    f.write(chunk)
                    downloaded += len(chunk)
                    percent = (downloaded / total_size) * 100
                    bar_length = 50
                    filled = int(bar_length * downloaded / total_size)
                    bar = '=' * filled + '-' * (bar_length - filled)
                    print(f'\r[{bar}] {percent:.1f}% ({format_size(downloaded)}/{format_size(total_size)})',
                          end='', flush=True)
                print()  # New line after completion

        # Rename partial file to final filename
        Path(temp_path).rename(output_path)

    except (KeyboardInterrupt, Exception) as e:
        # Clean up partial file
        if Path(temp_path).exists():
            Path(temp_path).unlink()
        
        if isinstance(e, KeyboardInterrupt):
            print("\n\nDownload cancelled.")
            sys.exit(130)
        raise e


def main():
    parser = argparse.ArgumentParser(
        description='Download .deb packages from APT repositories',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog='''
Examples:
  Using config file:
    %(prog)s --config packages.toml --install

  Interactive mode (or auto-select if only one package):
    %(prog)s --url "deb https://example.com/debian stable main"

  Specify package and version:
    %(prog)s --url "deb https://example.com/debian stable main" --package mypackage
    %(prog)s --url https://example.com/debian --dist stable --package mypackage --version 1.2.3

  Auto-install latest version:
    %(prog)s --url https://example.com/debian --dist stable --install

Config file format (TOML):
  [[packages]]
  name = "mypackage"
  url = "https://example.com/debian"
  distribution = "stable"
  component = "main"  # optional, defaults to "main"
        '''
    )

    parser.add_argument('--config', '-c', help='Path to TOML config file with package definitions')

    parser.add_argument('--url', help='Repository URL or full deb line')
    parser.add_argument('--dist', '--distribution', help='Distribution name (e.g., stable, focal)')
    parser.add_argument('--component', default='main', help='Component (default: main)')
    parser.add_argument('--package', help='Package name to download (auto-detected if only one available)')
    parser.add_argument('--version', help='Specific package version to download (default: latest)')
    parser.add_argument('--arch', help='Architecture (default: auto-detect)')
    parser.add_argument('--output-dir', '-o', default='/tmp', help='Output directory (default: /tmp)')
    parser.add_argument('--install', action='store_true', help='Install the package after downloading')
    parser.add_argument('--force', action='store_true', help='Force reinstall even if same version is already installed')
    parser.add_argument('--overwrite', action='store_true', help='Overwrite existing file if it exists')

    args = parser.parse_args()

    # Handle config file mode
    if args.config:
        config_path = Path(args.config).expanduser()
        if not config_path.exists():
            print(f"{Colors.RED}Error:{Colors.RESET} Config file not found: {config_path}")
            sys.exit(1)

        with open(config_path, 'rb') as f:
            config = tomllib.load(f)

        packages_config = config.get('packages', [])
        if not packages_config:
            print(f"{Colors.RED}Error:{Colors.RESET} No packages defined in config")
            sys.exit(1)

        arch = args.arch if args.arch else get_architecture()
        output_dir = Path(args.output_dir)
        output_dir.mkdir(parents=True, exist_ok=True)

        success_count = 0
        for pkg_config in packages_config:
            if process_package_config(pkg_config, arch, output_dir, args.install, args.force, args.overwrite):
                success_count += 1
            print()  # Blank line between packages

        total = len(packages_config)
        if success_count == total:
            print(f"{Colors.GREEN}All {total} packages processed successfully{Colors.RESET}")
        else:
            print(f"{Colors.YELLOW}{success_count}/{total} packages processed{Colors.RESET}")
            sys.exit(1)
        return

    # Determine if we're in non-interactive mode
    non_interactive = args.url and args.package

    # Get repository info
    if args.url:
        # Check if it's a full deb line or just a URL
        if args.url.startswith(('deb ', 'deb-src ', 'http://', 'https://')):
            if args.url.startswith(('deb ', 'deb-src ')):
                # Parse as full deb line
                try:
                    url, distribution, component = parse_repo_line(args.url)
                except ValueError as e:
                    print(f"Error: {e}")
                    sys.exit(1)
            else:
                # Just a URL, need distribution
                url = args.url.rstrip('/')
                if not args.dist:
                    # Try to auto-discover distributions
                    distributions = discover_distributions(url)

                    if len(distributions) == 1:
                        distribution = distributions[0]
                    elif len(distributions) > 1:
                        if non_interactive:
                            print(f"Error: Multiple distributions found: {', '.join(distributions)}")
                            print("Please specify one with --dist")
                            sys.exit(1)
                        # Interactive: let user choose
                        distribution = questionary.select(
                            "Select a distribution:",
                            choices=distributions
                        ).ask()
                        if not distribution:
                            sys.exit(1)
                    else:
                        # No distributions found
                        if non_interactive:
                            print("Error: Could not discover distributions. Please specify with --dist")
                            sys.exit(1)
                        distribution = questionary.text("Enter distribution name:").ask()
                        if not distribution:
                            sys.exit(1)
                else:
                    distribution = args.dist
                component = args.component
        else:
            print(f"Error: Invalid URL format: {args.url}")
            sys.exit(1)
    else:
        # Interactive mode: ask for repository line
        repo_line = questionary.text(
            "Paste your APT repository line:",
            instruction="(e.g., deb [signed-by=...] https://example.com/debian stable main)"
        ).ask()

        if not repo_line:
            print("No repository line provided.")
            sys.exit(1)

        try:
            url, distribution, component = parse_repo_line(repo_line)
        except ValueError as e:
            print(f"Error: {e}")
            sys.exit(1)

    # Get architecture
    arch = args.arch if args.arch else get_architecture()
    print(f"{Colors.BLUE}{url}/{distribution}/{component}/{arch}{Colors.RESET}")

    # Fetch packages
    try:
        packages = fetch_packages_list(url, distribution, component, arch)
    except Exception as e:
        print(f"Error fetching packages: {e}")
        sys.exit(1)

    if not packages:
        print(f"{Colors.RED}No packages found{Colors.RESET}")
        sys.exit(1)

    # Check if there's only one unique package name
    unique_packages = set(pkg.get('name') for pkg in packages)
    if len(unique_packages) == 1 and not args.package:
        # Auto-select the package name if there's only one
        args.package = list(unique_packages)[0]

    # Select package
    if args.package:
        # Non-interactive: find the specified package
        matching_packages = [pkg for pkg in packages if pkg.get('name') == args.package]

        if not matching_packages:
            print(f"Error: Package '{args.package}' not found in repository.")
            print(f"\nAvailable packages:")
            for pkg in packages:
                print(f"  - {pkg.get('name')}")
            sys.exit(1)

        if args.version and args.version != 'latest':
            # Find specific version
            selected = None
            for pkg in matching_packages:
                if pkg.get('version') == args.version:
                    selected = pkg
                    break

            if not selected:
                print(f"Error: Package '{args.package}' version '{args.version}' not found.")
                print(f"\nAvailable versions:")
                for pkg in matching_packages:
                    print(f"  - {pkg.get('version')}")
                sys.exit(1)

            pass
        else:
            # Find the latest version
            selected = matching_packages[0]
            for pkg in matching_packages[1:]:
                if compare_versions(pkg.get('version', '0'), selected.get('version', '0')) > 0:
                    selected = pkg

        print(f"{Colors.GREEN}→{Colors.RESET} {selected.get('name')} {Colors.BOLD}{selected.get('version')}{Colors.RESET}")
    else:
        # Interactive: show menu
        choices = []
        for pkg in packages:
            name = pkg.get('name', 'unknown')
            version = pkg.get('version', 'unknown')
            size = format_size(pkg.get('size', 0))
            description = pkg.get('description', 'No description')

            # Truncate description if too long
            if len(description) > 60:
                description = description[:57] + '...'

            label = f"{name:20s} {version:15s} {size:10s} | {description}"
            choices.append(questionary.Choice(title=label, value=pkg))

        selected = questionary.select(
            "Select a package to download:",
            choices=choices,
            use_shortcuts=True,
            use_arrow_keys=True,
        ).ask()

        if not selected:
            print("No package selected.")
            sys.exit(1)

    # Download the selected package
    filename = selected.get('filename')
    if not filename:
        print("Error: No filename found for package")
        sys.exit(1)

    # Create output directory if it doesn't exist
    output_dir = Path(args.output_dir)
    output_dir.mkdir(parents=True, exist_ok=True)

    # Build full output path
    output_path = output_dir / Path(filename).name

    try:
        if output_path.exists() and not args.overwrite:
            print(f"{Colors.YELLOW}✓{Colors.RESET} Cached: {output_path.name}")
        else:
            download_package(url, filename, str(output_path))
            print(f"\n{Colors.GREEN}✓{Colors.RESET} Downloaded: {output_path.name}")

        if args.install:
            # Check if same version is already installed
            installed_version = get_installed_version(selected.get('name'))
            target_version = selected.get('version')

            if installed_version == target_version and not args.force:
                print(f"{Colors.GREEN}✓{Colors.RESET} Already installed")
            else:
                if installed_version:
                    print(f"{Colors.YELLOW}↑{Colors.RESET} Upgrading from {installed_version}")
                try:
                    subprocess.run(['sudo', 'dpkg', '-i', str(output_path)], check=True, capture_output=True)
                    print(f"{Colors.GREEN}✓{Colors.RESET} Installed")
                except subprocess.CalledProcessError:
                    try:
                        subprocess.run(['sudo', 'apt-get', 'install', '-f', '-y'], check=True, capture_output=True)
                        print(f"{Colors.GREEN}✓{Colors.RESET} Installed (dependencies fixed)")
                    except subprocess.CalledProcessError:
                        print(f"{Colors.RED}✗{Colors.RESET} Installation failed")
                        sys.exit(1)

    except Exception as e:
        print(f"\nError processing package: {e}")
        sys.exit(1)


if __name__ == '__main__':
    main()
